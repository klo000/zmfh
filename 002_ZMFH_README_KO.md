# ZMFH 프로젝트 README

ZMFH는 Python의 import 동작을 대체·확장하는 **상위 언어 계층(Upper Language Layer)** 이다.  
Python 문법은 그대로 두고, import·실행·모듈 접근을 **정책과 계약의 문제**로 재정의한다.

## 1) 프로젝트 목적

ZMFH의 목적은 하나다.

> 개발자가 import 때문에 사고하지 않게 만든다.

ZMFH는 새로운 언어를 만들지 않는다.  
Python이 의도적으로 비워둔 구조적 공백을 시스템 레벨에서 메운다.

## 2) 문제 정의

기존 Python import 시스템의 한계:

- 실행 위치에 따라 import 성공/실패가 달라진다
- 상대 import / 절대 import 규칙이 규모가 커질수록 직관적이지 않다
- `sys.path` 조작이 관습처럼 굳어진다
- 프로젝트가 커질수록 구조 설명 비용이 폭증한다
- 실패 원인을 즉시 단정적으로 파악하기 어렵다

이건 숙련도의 문제가 아니라 **거버넌스 공백**이다.

## 3) 핵심 원칙

1. **기존 코드 무침투**
   - 코드 수정 없이 적용
   - Python import 문법 그대로 사용

2. **설정 강요 없음**
   - config 파일 강제 없음
   - `__init__.py` 의존, `sys.path` 꼼수 의존 없음

3. **파일명 기반 인식**
   - 파일명이 식별자 역할
   - 위치보다 의미를 우선

4. **정책 기반 허용**
   - import는 자유가 아니라 권한
   - 허용/차단은 중앙 정책으로 결정

5. **명확한 실패**
   - 실패 시 이유를 단정적으로 제공
   - 암묵적 성공/조용한 실패 없음

## 4) ZMFH의 정체성

ZMFH는 라이브러리가 아니다.  
ZMFH는 프레임워크도 아니다.

ZMFH는 Python 위에 얹히는 **상위 언어 계층**이다.

- 문법: Python
- 의미(semantics): ZMFH
- 실행 질서: ZMFH
- import 거버넌스: ZMFH

체감:

> 문법은 파이썬인데, 함부로 못 한다.

## 5) 구조 개요 (개념)

- **Global Index**: 프로젝트 전체 모듈을 인덱싱, 경로가 아닌 키 기반 접근
- **Registry**: 존재 모듈 관리, 기존 코드도 import 순간 인식 가능
- **Policy Layer**: 허용/차단 규칙, 조직·부서·프로젝트 범위 지원
- **Resolver**: 실행 위치와 무관하게 import 요청을 해석
- **Evidence / Log**: 모든 import 시도 기록(감사/디버깅/재현성)

## 6) 중첩 구조 (확장성)

ZMFH는 **중첩 계층**을 지원한다.

- 조직 ZMFH
  - 부서 ZMFH
    - 팀 ZMFH
      - 프로젝트 ZMFH

각 계층은 독립적인 정책을 갖고,  
상위 계층은 경계만 통제하며 하위는 자율을 유지한다.

## 7) 기대 효과

- import 관련 사고 제거
- 구조 설명 비용 급감
- 신입/경력 생산성 격차 축소
- 코드 리뷰의 초점이 구조로 이동
- 대형·장기 프로젝트 유지 가능

규모가 커지는 순간, 이건 선택이 아니라 인프라가 된다.

## 8) 포지셔닝

ZMFH는 Python을 대체하지 않는다.  
ZMFH는 Python 생태계를 깨지 않는다.

ZMFH는 Python이 규모에서 못 들어가던 영역에  
Python을 진입시키는 구조다.

## 9) 프로젝트 상태

- 대형 프로젝트의 실사용 문제에서 출발
- ALP 프로젝트 내부 검증
- 독립 오픈 프로젝트로 분리 진행

## 10) 한 줄 요약

ZMFH는 import를 문법에서 해방시켜 **거버넌스와 계약**으로 끌어올린 Python 상위 언어 계층이다.
