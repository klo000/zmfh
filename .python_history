
from pathlib import Path
import re

p = Path(r"D:\camin\core\core_alpha\ai\main_ai.py")
s = p.read_text(encoding="utf-8", errors="replace")

# 기존 _extract_text_from_ctx 함수 블록을 찾아 교체한다.
pat = re.compile(r"def _extract_text_from_ctx\(ctx: Any\) -> str:\n(?:.*\n){1,60}?\s*return \"\"\n", re.M)

m = pat.search(s)
if not m:
    raise SystemExit("patch target not found: _extract_text_from_ctx")

new_fn = """def _extract_text_from_ctx(ctx: Any) -> str:
    # 1) direct attrs / dict keys
    for k in ("text", "output", "result", "message"):
        try:
            v = getattr(ctx, k, None)
            if isinstance(v, str) and v.strip():
                return v
        except Exception:
            pass
        try:
            if isinstance(ctx, dict):
                v2 = ctx.get(k)
                if isinstance(v2, str) and v2.strip():
                    return v2
        except Exception:
            pass

    # 2) ctx.data (subcore가 결과를 여기 넣는 경우가 많다)
    data = None
    try:
        data = getattr(ctx, "data", None)
    except Exception:
        data = None
    if isinstance(ctx, dict) and isinstance(ctx.get("data"), dict):
        data = ctx.get("data")

    if isinstance(data, dict):
        # 흔히 쓰는 키 후보들
        for k in ("text", "output", "result", "message", "final_text", "answer", "final", "content"):
            v = data.get(k)
            if isinstance(v, str) and v.strip():
                return v

        # 중첩 dict에 들어간 경우까지 1단계만 탐색
        for kk in ("response", "resp", "out", "payload"):
            vv = data.get(kk)
            if isinstance(vv, dict):
                for k in ("text", "output", "result", "message", "final_text", "answer", "final", "content"):
                    v = vv.get(k)
                    if isinstance(v, str) and v.strip():
                        return v

    # 3) 마지막 보험: 로그가 있으면 마지막 한 줄이라도 뽑는다
    try:
        logs = getattr(ctx, "logs", None)
        if isinstance(logs, list) and logs:
            tail = str(logs[-1]).strip()
            if tail:
                return tail
    except Exception:
        pass
    if isinstance(ctx, dict) and isinstance(ctx.get("logs"), list) and ctx["logs"]:
        tail = str(ctx["logs"][-1]).strip()
        if tail:
            return tail

    return ""
"""

s2 = s[:m.start()] + new_fn + s[m.end():]
p.write_text(s2, encoding="utf-8")
print("PATCH OK:", p)
PY

from pathlib import Path
import re

p = Path(r"D:\camin\core\core_alpha\ai\main_ai.py")
s = p.read_text(encoding="utf-8", errors="replace")

# 기존 _extract_text_from_ctx 함수 블록을 찾아 교체한다.
pat = re.compile(r"def _extract_text_from_ctx\(ctx: Any\) -> str:\n(?:.*\n){1,60}?\s*return \"\"\n", re.M)

m = pat.search(s)
if not m:
    raise SystemExit("patch target not found: _extract_text_from_ctx")

new_fn = """def _extract_text_from_ctx(ctx: Any) -> str:
    # 1) direct attrs / dict keys
    for k in ("text", "output", "result", "message"):
        try:
            v = getattr(ctx, k, None)
            if isinstance(v, str) and v.strip():
                return v
        except Exception:
            pass
        try:
            if isinstance(ctx, dict):
                v2 = ctx.get(k)
                if isinstance(v2, str) and v2.strip():
                    return v2
        except Exception:
            pass

    # 2) ctx.data (subcore가 결과를 여기 넣는 경우가 많다)
    data = None
    try:
        data = getattr(ctx, "data", None)
    except Exception:
        data = None
    if isinstance(ctx, dict) and isinstance(ctx.get("data"), dict):
        data = ctx.get("data")

    if isinstance(data, dict):
        # 흔히 쓰는 키 후보들
        for k in ("text", "output", "result", "message", "final_text", "answer", "final", "content"):
            v = data.get(k)
            if isinstance(v, str) and v.strip():
                return v

        # 중첩 dict에 들어간 경우까지 1단계만 탐색
        for kk in ("response", "resp", "out", "payload"):
            vv = data.get(kk)
            if isinstance(vv, dict):
                for k in ("text", "output", "result", "message", "final_text", "answer", "final", "content"):
                    v = vv.get(k)
                    if isinstance(v, str) and v.strip():
                        return v

    # 3) 마지막 보험: 로그가 있으면 마지막 한 줄이라도 뽑는다
    try:
        logs = getattr(ctx, "logs", None)
        if isinstance(logs, list) and logs:
            tail = str(logs[-1]).strip()
            if tail:
                return tail
    except Exception:
        pass
    if isinstance(ctx, dict) and isinstance(ctx.get("logs"), list) and ctx["logs"]:
        tail = str(ctx["logs"][-1]).strip()
        if tail:
            return tail

    return ""
"""

s2 = s[:m.start()] + new_fn + s[m.end():]
p.write_text(s2, encoding="utf-8")
print("PATCH OK:", p)
PY
from cx_context_bootstrap import CX_context_default_manager

mgr, folders = CX_context_default_manager(project_root="D:/ALP")
sess = mgr.current()

mgr.ingest("system", "You are CX.")
mgr.ingest("user", "컨텍스트 테스트")

print(sess.session_id)
print(mgr.snapshot_current())
from cx_context_bootstrap import CX_context_default_manager

mgr, folders = CX_context_default_manager(project_root="D:/ALP")
sess = mgr.current()

mgr.ingest("system", "You are CX.")
mgr.ingest("user", "컨텍스트 테스트")

print(sess.session_id)
print(mgr.snapshot_current())
cd D:\ALP

$repls = @(
  @{ old = 'from core\.ALP_ImportHub import ALP_ImportHub'; new = 'from cx_import.cx_ALP_ImportHub import ALP_ImportHub' },
  @{ old = 'from core\.ALP_ImportPolicy import ALP_ImportPolicy'; new = 'from cx_import.cx_ALP_ImportPolicy import ALP_ImportPolicy' },
  @{ old = 'from core\.ALP_ImportWatchHub import'; new = 'from cx_import.cx_ALP_ImportWatchHub import' }
)

Get-ChildItem -Path . -Recurse -Filter *.py | ForEach-Object {
  $p = $_.FullName
  $txt = Get-Content -Raw -LiteralPath $p
  $orig = $txt

  foreach($r in $repls){
    $txt = [regex]::Replace($txt, $r.old, $r.new)
  }

  if($txt -ne $orig){
    Set-Content -LiteralPath $p -Value $txt -NoNewline
    Write-Host "patched: $p"
  }
}

$repls = @(
  @{ old = 'from core\.ALP_ImportHub import ALP_ImportHub'; new = 'from cx_import.cx_ALP_ImportHub import ALP_ImportHub' },
  @{ old = 'from core\.ALP_ImportPolicy import ALP_ImportPolicy'; new = 'from cx_import.cx_ALP_ImportPolicy import ALP_ImportPolicy' },
  @{ old = 'from core\.ALP_ImportWatchHub import'; new = 'from cx_import.cx_ALP_ImportWatchHub import' }
)

Get-ChildItem -Path . -Recurse -Filter *.py | ForEach-Object {
  $p = $_.FullName
  $txt = Get-Content -Raw -LiteralPath $p
  $orig = $txt

  foreach($r in $repls){
    $txt = [regex]::Replace($txt, $r.old, $r.new)
  }

  if($txt -ne $orig){
    Set-Content -LiteralPath $p -Value $txt -NoNewline
    Write-Host "patched: $p"
  }
}
# ===== 설정 =====
$BrainZip = "D:\ALP\cx_ALP\cx_ai\brain.zip"
$DstRoot  = "D:\ALP\cx_ALP\cx_ai\cx_brain_layer"

# ===== 안전 체크 =====
if (!(Test-Path $BrainZip)) { throw "brain.zip not found: $BrainZip" }
if (!(Test-Path $DstRoot))  { throw "cx_brain_layer not found: $DstRoot" }

$tmp = Join-Path $env:TEMP ("alp_brainzip_" + [guid]::NewGuid().ToString("N"))
New-Item -ItemType Directory -Force -Path $tmp | Out-Null
Expand-Archive -Force $BrainZip $tmp

$src = Join-Path $tmp "brain"
if (!(Test-Path $src)) { throw "brain/ folder not found inside zip: $BrainZip" }

# ===== 대상 폴더 =====
$dstBrain   = Join-Path $DstRoot "cx_brain"
$dstContext = Join-Path $DstRoot "cx_context"
New-Item -ItemType Directory -Force -Path $dstBrain   | Out-Null
New-Item -ItemType Directory -Force -Path $dstContext | Out-Null

# ===== 배치 규칙 =====
# 1) context.py는 cx_context 레이어로 이동 (핵심)
# 2) 나머지는 cx_brain 레이어로 이동
# 3) __init__.py는 폐기

# context.py -> cx_context/cx_context_context_manager.py
$srcContext = Join-Path $src "context.py"
if (Test-Path $srcContext) {
    Copy-Item -Force $srcContext (Join-Path $dstContext "cx_context_context_manager.py")
}

# 나머지 -> cx_brain/cx_*.py
Get-ChildItem -Path $src -Filter "*.py" | ForEach-Object {
    if ($_.Name -ieq "__init__.py") { return }
    if ($_.Name -ieq "context.py")  { return }

    $base = [System.IO.Path]::GetFileNameWithoutExtension($_.Name)
    $dst  = Join-Path $dstBrain ("cx_" + $base + ".py")
    Copy-Item -Force $_.FullName $dst
}

# ===== 상대 import(.xxx) -> flat import(cx_xxx) 자동 치환 =====
# 적용 대상: cx_brain/*.py, cx_context/cx_context_context_manager.py
function Fix-Imports($filePath) {
    $txt = Get-Content -Raw -Encoding UTF8 $filePath

    # from .foo import Bar  -> from cx_foo import Bar
    $txt = $txt -replace '(^|\r?\n)\s*from\s+\.(\w+)\s+import\s+', "`$1from cx_`$2 import "

    # from .foo import ( ... ) 형태도 동일 처리
    $txt = $txt -replace '(^|\r?\n)\s*from\s+\.(\w+)\s+import\s*\(', "`$1from cx_`$2 import ("

    Set-Content -Encoding UTF8 -Path $filePath -Value $txt
}

Get-ChildItem -Path $dstBrain -Filter "cx_*.py" | ForEach-Object { Fix-Imports $_.FullName }
$ctxMgr = Join-Path $dstContext "cx_context_context_manager.py"
if (Test-Path $ctxMgr) { Fix-Imports $ctxMgr }

# ===== cx_brain/cx_context.py shim 생성(기존 참조 깨짐 방지) =====
@'
# shim: context 구현은 cx_context 레이어로 이동됨
from cx_context_context_manager import *  # noqa: F401,F403
'@ | Set-Content -Encoding UTF8 (Join-Path $dstBrain "cx_context.py")

# ===== 정리 =====
Remove-Item -Recurse -Force $tmp

"OK: brain.zip auto-placed into cx_brain_layer (brain->cx_brain, context->cx_context) and imports flattened."
# ===== 설정 =====
$BrainZip = "D:\ALP\cx_ALP\cx_ai\brain.zip"
$DstRoot  = "D:\ALP\cx_ALP\cx_ai\cx_brain_layer"

# ===== 안전 체크 =====
if (!(Test-Path $BrainZip)) { throw "brain.zip not found: $BrainZip" }
if (!(Test-Path $DstRoot))  { throw "cx_brain_layer not found: $DstRoot" }

$tmp = Join-Path $env:TEMP ("alp_brainzip_" + [guid]::NewGuid().ToString("N"))
New-Item -ItemType Directory -Force -Path $tmp | Out-Null
Expand-Archive -Force $BrainZip $tmp

$src = Join-Path $tmp "brain"
if (!(Test-Path $src)) { throw "brain/ folder not found inside zip: $BrainZip" }

# ===== 대상 폴더 =====
$dstBrain   = Join-Path $DstRoot "cx_brain"
$dstContext = Join-Path $DstRoot "cx_context"
New-Item -ItemType Directory -Force -Path $dstBrain   | Out-Null
New-Item -ItemType Directory -Force -Path $dstContext | Out-Null

# ===== 배치 규칙 =====
# 1) context.py는 cx_context 레이어로 이동 (핵심)
# 2) 나머지는 cx_brain 레이어로 이동
# 3) __init__.py는 폐기

# context.py -> cx_context/cx_context_context_manager.py
$srcContext = Join-Path $src "context.py"
if (Test-Path $srcContext) {
    Copy-Item -Force $srcContext (Join-Path $dstContext "cx_context_context_manager.py")
}

# 나머지 -> cx_brain/cx_*.py
Get-ChildItem -Path $src -Filter "*.py" | ForEach-Object {
    if ($_.Name -ieq "__init__.py") { return }
    if ($_.Name -ieq "context.py")  { return }

    $base = [System.IO.Path]::GetFileNameWithoutExtension($_.Name)
    $dst  = Join-Path $dstBrain ("cx_" + $base + ".py")
    Copy-Item -Force $_.FullName $dst
}

# ===== 상대 import(.xxx) -> flat import(cx_xxx) 자동 치환 =====
# 적용 대상: cx_brain/*.py, cx_context/cx_context_context_manager.py
function Fix-Imports($filePath) {
    $txt = Get-Content -Raw -Encoding UTF8 $filePath

    # from .foo import Bar  -> from cx_foo import Bar
    $txt = $txt -replace '(^|\r?\n)\s*from\s+\.(\w+)\s+import\s+', "`$1from cx_`$2 import "

    # from .foo import ( ... ) 형태도 동일 처리
    $txt = $txt -replace '(^|\r?\n)\s*from\s+\.(\w+)\s+import\s*\(', "`$1from cx_`$2 import ("

    Set-Content -Encoding UTF8 -Path $filePath -Value $txt
}

Get-ChildItem -Path $dstBrain -Filter "cx_*.py" | ForEach-Object { Fix-Imports $_.FullName }
$ctxMgr = Join-Path $dstContext "cx_context_context_manager.py"
if (Test-Path $ctxMgr) { Fix-Imports $ctxMgr }

# ===== cx_brain/cx_context.py shim 생성(기존 참조 깨짐 방지) =====
@'
# shim: context 구현은 cx_context 레이어로 이동됨
from cx_context_context_manager import *  # noqa: F401,F403
'@ | Set-Content -Encoding UTF8 (Join-Path $dstBrain "cx_context.py")

# ===== 정리 =====
Remove-Item -Recurse -Force $tmp

"OK: brain.zip auto-placed into cx_brain_layer (brain->cx_brain, context->cx_context) and imports flattened."
# ===== 설정 =====
$BrainZip = "D:\ALP\cx_ALP\cx_ai\brain.zip"
$DstRoot  = "D:\ALP\cx_ALP\cx_ai\cx_brain_layer"

# ===== 안전 체크 =====
if (!(Test-Path $BrainZip)) { throw "brain.zip not found: $BrainZip" }
if (!(Test-Path $DstRoot))  { throw "cx_brain_layer not found: $DstRoot" }

$tmp = Join-Path $env:TEMP ("alp_brainzip_" + [guid]::NewGuid().ToString("N"))
New-Item -ItemType Directory -Force -Path $tmp | Out-Null
Expand-Archive -Force $BrainZip $tmp

$src = Join-Path $tmp "brain"
if (!(Test-Path $src)) { throw "brain/ folder not found inside zip: $BrainZip" }

# ===== 대상 폴더 =====
$dstBrain   = Join-Path $DstRoot "cx_brain"
$dstContext = Join-Path $DstRoot "cx_context"
New-Item -ItemType Directory -Force -Path $dstBrain   | Out-Null
New-Item -ItemType Directory -Force -Path $dstContext | Out-Null

# ===== 배치 규칙 =====
# 1) context.py는 cx_context 레이어로 이동 (핵심)
# 2) 나머지는 cx_brain 레이어로 이동
# 3) __init__.py는 폐기

# context.py -> cx_context/cx_context_context_manager.py
$srcContext = Join-Path $src "context.py"
if (Test-Path $srcContext) {
    Copy-Item -Force $srcContext (Join-Path $dstContext "cx_context_context_manager.py")
}

# 나머지 -> cx_brain/cx_*.py
Get-ChildItem -Path $src -Filter "*.py" | ForEach-Object {
    if ($_.Name -ieq "__init__.py") { return }
    if ($_.Name -ieq "context.py")  { return }

    $base = [System.IO.Path]::GetFileNameWithoutExtension($_.Name)
    $dst  = Join-Path $dstBrain ("cx_" + $base + ".py")
    Copy-Item -Force $_.FullName $dst
}

# ===== 상대 import(.xxx) -> flat import(cx_xxx) 자동 치환 =====
# 적용 대상: cx_brain/*.py, cx_context/cx_context_context_manager.py
function Fix-Imports($filePath) {
    $txt = Get-Content -Raw -Encoding UTF8 $filePath

    # from .foo import Bar  -> from cx_foo import Bar
    $txt = $txt -replace '(^|\r?\n)\s*from\s+\.(\w+)\s+import\s+', "`$1from cx_`$2 import "

    # from .foo import ( ... ) 형태도 동일 처리
    $txt = $txt -replace '(^|\r?\n)\s*from\s+\.(\w+)\s+import\s*\(', "`$1from cx_`$2 import ("

    Set-Content -Encoding UTF8 -Path $filePath -Value $txt
}

Get-ChildItem -Path $dstBrain -Filter "cx_*.py" | ForEach-Object { Fix-Imports $_.FullName }
$ctxMgr = Join-Path $dstContext "cx_context_context_manager.py"
if (Test-Path $ctxMgr) { Fix-Imports $ctxMgr }

# ===== cx_brain/cx_context.py shim 생성(기존 참조 깨짐 방지) =====
@'
# shim: context 구현은 cx_context 레이어로 이동됨
from cx_context_context_manager import *  # noqa: F401,F403
'@ | Set-Content -Encoding UTF8 (Join-Path $dstBrain "cx_context.py")

# ===== 정리 =====
Remove-Item -Recurse -Force $tmp

"OK: brain.zip auto-placed into cx_brain_layer (brain->cx_brain, context->cx_context) and imports flattened."
@
@
@# ===== 설정 =====
$BrainZip = "D:\ALP\cx_ALP\cx_ai\brain.zip"
$DstRoot  = "D:\ALP\cx_ALP\cx_ai\cx_brain_layer"

# ===== 안전 체크 =====
if (!(Test-Path $BrainZip)) { throw "brain.zip not found: $BrainZip" }
if (!(Test-Path $DstRoot))  { throw "cx_brain_layer not found: $DstRoot" }

$tmp = Join-Path $env:TEMP ("alp_brainzip_" + [guid]::NewGuid().ToString("N"))
New-Item -ItemType Directory -Force -Path $tmp | Out-Null
Expand-Archive -Force $BrainZip $tmp

$src = Join-Path $tmp "brain"
if (!(Test-Path $src)) { throw "brain/ folder not found inside zip: $BrainZip" }

# ===== 대상 폴더 =====
$dstBrain   = Join-Path $DstRoot "cx_brain"
$dstContext = Join-Path $DstRoot "cx_context"
New-Item -ItemType Directory -Force -Path $dstBrain   | Out-Null
New-Item -ItemType Directory -Force -Path $dstContext | Out-Null

# ===== 배치 규칙 =====
# 1) context.py는 cx_context 레이어로 이동 (핵심)
# 2) 나머지는 cx_brain 레이어로 이동
# 3) __init__.py는 폐기

# context.py -> cx_context/cx_context_context_manager.py
$srcContext = Join-Path $src "context.py"
if (Test-Path $srcContext) {
    Copy-Item -Force $srcContext (Join-Path $dstContext "cx_context_context_manager.py")
}

# 나머지 -> cx_brain/cx_*.py
Get-ChildItem -Path $src -Filter "*.py" | ForEach-Object {
    if ($_.Name -ieq "__init__.py") { return }
    if ($_.Name -ieq "context.py")  { return }

    $base = [System.IO.Path]::GetFileNameWithoutExtension($_.Name)
    $dst  = Join-Path $dstBrain ("cx_" + $base + ".py")
    Copy-Item -Force $_.FullName $dst
}

# ===== 상대 import(.xxx) -> flat import(cx_xxx) 자동 치환 =====
# 적용 대상: cx_brain/*.py, cx_context/cx_context_context_manager.py
function Fix-Imports($filePath) {
    $txt = Get-Content -Raw -Encoding UTF8 $filePath

    # from .foo import Bar  -> from cx_foo import Bar
    $txt = $txt -replace '(^|\r?\n)\s*from\s+\.(\w+)\s+import\s+', "`$1from cx_`$2 import "

    # from .foo import ( ... ) 형태도 동일 처리
    $txt = $txt -replace '(^|\r?\n)\s*from\s+\.(\w+)\s+import\s*\(', "`$1from cx_`$2 import ("

    Set-Content -Encoding UTF8 -Path $filePath -Value $txt
}

Get-ChildItem -Path $dstBrain -Filter "cx_*.py" | ForEach-Object { Fix-Imports $_.FullName }
$ctxMgr = Join-Path $dstContext "cx_context_context_manager.py"
if (Test-Path $ctxMgr) { Fix-Imports $ctxMgr }

# ===== cx_brain/cx_context.py shim 생성(기존 참조 깨짐 방지) =====
@'
# shim: context 구현은 cx_context 레이어로 이동됨
from cx_context_context_manager import *  # noqa: F401,F403
'@ | Set-Content -Encoding UTF8 (Join-Path $dstBrain "cx_context.py")

# ===== 정리 =====
Remove-Item -Recurse -Force $tmp

"OK: brain.zip auto-placed into cx_brain_layer (brain->cx_brain, context->cx_context) and imports flattened."
python - <<'PY'
import zmfh
print("zmfh has hooks?", hasattr(zmfh, "hooks"))
try:
    from zmfh import hooks
    print("hooks.enable exists?", hasattr(hooks, "enable"))
    if hasattr(hooks, "enable"):
        hooks.enable()
        import sys
        print("meta_path(after enable)=", [type(x).__name__ for x in sys.meta_path][:10])
except Exception as e:
    print("enable error:", repr(e))
PY

python - <<'PY'
import zmfh
print("zmfh has hooks?", hasattr(zmfh, "hooks"))
try:
    from zmfh import hooks
    print("hooks.enable exists?", hasattr(hooks, "enable"))
    if hasattr(hooks, "enable"):
        hooks.enable()
        import sys
        print("meta_path(after enable)=", [type(x).__name__ for x in sys.meta_path][:10])
except Exception as e:
    print("enable error:", repr(e))
PY

exit()
